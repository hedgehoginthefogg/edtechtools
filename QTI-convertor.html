<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz to QTI Converter (JS Version)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: auto; }
        textarea { width: 95%; min-height: 200px; margin-bottom: 10px; padding: 10px; border: 1px solid #ccc; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="password"], input[type="text"] { width: 95%; padding: 8px; margin-bottom: 15px; border: 1px solid #ccc; }
        button { padding: 10px 20px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        #status { margin-top: 15px; padding: 10px; border-radius: 4px; white-space: pre-wrap; } /* Allow wrapping */
        .status-info { background-color: #e0e0e0; }
        .status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        pre { background-color: #f4f4f4; padding: 10px; border: 1px solid #ddd; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; } /* For debugging output */
    </style>
</head>
<body>
    <h1>Quiz Text to QTI Converter (JS/PHP Version)</h1>
    <p>Paste quiz text. The PHP backend will call Gemini, and JavaScript will generate the QTI v2.1 ZIP.</p>

    <label for="quizText">Quiz Text:</label>
    <textarea id="quizText" placeholder="Paste your quiz here..."></textarea>

    <label for="qPrefix">Question Name Prefix (Optional):</label>
    <input type="text" id="qPrefix" placeholder="e.g., ABCD 1234">

    <label for="apiKey">Your Google AI Studio API Key (Gemini):</label>
    <input type="password" id="apiKey" placeholder="Enter your Gemini API Key (used only for API call via PHP)">

    <button id="convertBtn">Convert to QTI ZIP</button>

    <div id="status"></div>
    <script>
        const quizTextInput = document.getElementById('quizText');
        const apiKeyInput = document.getElementById('apiKey');
        const prefixInput = document.getElementById('qPrefix');
        const convertBtn = document.getElementById('convertBtn');
        const statusDiv = document.getElementById('status');
        // const debugPre = document.querySelector('#debugOutput pre'); // Uncomment for debug output

        // --- Main Event Listener ---
        convertBtn.addEventListener('click', async () => {
            const quizText = quizTextInput.value.trim();
            const apiKey = apiKeyInput.value.trim();
            const qPrefix = prefixInput.value.trim();

            // Clear previous debug output
            // if (debugPre) debugPre.textContent = '';

            if (!quizText || !apiKey) {
                showStatus('Please paste quiz text and enter your API Key.', 'error');
                return;
            }

            showStatus('Processing... Contacting server proxy.', 'info');
            convertBtn.disabled = true;

            try {
                // --- Step 1: Call the PHP Proxy ---
                const response = await fetch('proxy.php', { // Point to your PHP script
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json', // Expect JSON back
                    },
                    body: JSON.stringify({
                        quiz_text: quizText,
                        api_key: apiKey
                        // No need to send prefix here, JS handles naming
                    }),
                });

                // --- Step 2: Handle Proxy Response ---
                const responseBodyText = await response.text(); // Get raw text first for debugging
                // if (debugPre) debugPre.textContent += `Raw Response from proxy.php:\n${responseBodyText}\n\n`;

                if (!response.ok) {
                    // Try to parse error JSON from PHP/Gemini
                    let errorMsg = `Server proxy error (Status: ${response.status})`;
                    try {
                        const errorData = JSON.parse(responseBodyText);
                        errorMsg = `Error: ${errorData.error || responseBodyText}`;
                        if(errorData.details) {
                            errorMsg += `\nDetails: ${JSON.stringify(errorData.details)}`;
                        } else if (errorData.reason) {
                             errorMsg += `\nReason: ${errorData.reason}`;
                        }
                    } catch (parseError) {
                       errorMsg += `\nResponse body: ${responseBodyText}`; // Show raw response if not JSON
                    }
                    throw new Error(errorMsg);
                }

                // Attempt to parse the JSON data (expected from Gemini via PHP)
                let geminiData;
                try {
                    geminiData = JSON.parse(responseBodyText);
                    // if (debugPre) debugPre.textContent += `Parsed Gemini Data:\n${JSON.stringify(geminiData, null, 2)}\n\n`;
                } catch (e) {
                    throw new Error(`Failed to parse JSON response from server: ${e.message}\nResponse Body: ${responseBodyText}`);
                }


                if (!Array.isArray(geminiData)) {
                     throw new Error('Parsed data is not a valid array as expected from Gemini.');
                }
                 if (geminiData.length === 0) {
                     throw new Error('Parsing resulted in zero questions.');
                 }


                showStatus(`Received ${geminiData.length} questions from parser. Generating QTI...`, 'info');

                // --- Step 3: Generate QTI XML in JavaScript ---
                const qtiItems = generateQtiItems(geminiData, qPrefix);
                const manifestXml = generateManifestXml(qtiItems);

                // if (debugPre && qtiItems.length > 0) {
                //      debugPre.textContent += `Generated QTI Item 1 XML:\n${qtiItems[0].xmlString}\n\n`;
                //      debugPre.textContent += `Generated Manifest XML:\n${manifestXml}\n\n`;
                // }


                showStatus('Generating ZIP file...', 'info');

                // --- Step 4: Create ZIP file in JavaScript ---
                const zip = new JSZip();
                qtiItems.forEach(item => {
                    if (item && item.filename && item.xmlString) {
                         zip.file(item.filename, item.xmlString);
                    } else {
                         console.warn("Skipping invalid item during zipping:", item);
                    }
                });
                zip.file("imsmanifest.xml", manifestXml);

                const zipBlob = await zip.generateAsync({ type: "blob" });

                // --- Step 5: Trigger Download ---
                const downloadUrl = window.URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = downloadUrl;
                a.download = 'quiz_qti_inspera.zip'; // Set the download filename
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(downloadUrl);
                a.remove();
                showStatus('Download started successfully!', 'success');


            } catch (error) {
                console.error('Conversion Error:', error);
                showStatus(`An error occurred: ${error.message}`, 'error');
            } finally {
                convertBtn.disabled = false;
            }
        });

        // --- Helper Functions ---

        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `status-${type}`;
        }

        function escapeXml(unsafe) {
            if (typeof unsafe !== 'string') {
                return unsafe; // Return non-strings as is
            }
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        function generateUUID() { // Simple UUID generator
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // --- QTI/XML Generation Functions (JavaScript) ---

        function generateQtiItems(parsedQuestions, prefix) {
            const items = [];
            parsedQuestions.forEach((qData, index) => {
                if (!qData || typeof qData !== 'object' || !qData.question_stem || !Array.isArray(qData.options) || !qData.correct_answer) {
                     console.error(`Skipping invalid question data at index ${index}:`, qData);
                     showStatus(`Warning: Skipped invalid question data structure at index ${index}. Check Gemini output.`, 'error');
                     return; // Skip this invalid item
                }

                const itemIndex = index; // 0-based index
                const itemIdentifier = `item_${itemIndex}_${generateUUID()}`;
                const questionStem = escapeXml(qData.question_stem);
                const options = qData.options;
                const correctAnswerText = qData.correct_answer; // Don't escape this yet, need it for comparison

                let itemTitle = `Question ${itemIndex + 1}`;
                if (prefix) {
                    itemTitle = `${escapeXml(prefix)} Q${itemIndex + 1}`;
                }

                let choiceIdentifierMap = {}; // Map option text to choice ID
                let correctChoiceId = null;

                let optionsXml = '';
                options.forEach((option, optIndex) => {
                    if (option === null || option === undefined) {
                         console.warn(`Null/undefined option found in question ${itemIndex}, index ${optIndex}`);
                         option = ""; // Treat as empty string
                    }
                    const choiceId = `choice_${optIndex}_${generateUUID()}`;
                    const escapedOptionText = escapeXml(option.toString()); // Ensure string and escape
                    choiceIdentifierMap[option.toString()] = choiceId; // Use original string for map key
                    optionsXml += `    <simpleChoice identifier="${choiceId}">${escapedOptionText}</simpleChoice>\n`;
                    if (option.toString() === correctAnswerText) {
                        correctChoiceId = choiceId;
                    }
                });

                if (!correctChoiceId && options.length > 0) {
                     console.warn(`Correct answer '${correctAnswerText}' not found for question ${itemIndex}. Defaulting to first option.`);
                     correctChoiceId = choiceIdentifierMap[options[0].toString()]; // Default to first
                }
                 if (!correctChoiceId) {
                      console.error(`Cannot determine correct answer ID for question ${itemIndex}.`);
                      // Decide how to handle - skip item or create potentially invalid QTI?
                      // For now, we'll create it without a valid correctResponse value.
                      correctChoiceId = "UNKNOWN_CORRECT_ID";
                 }


                const qtiString = `<?xml version="1.0" encoding="UTF-8"?>
<assessmentItem xmlns="[http://www.imsglobal.org/xsd/imsqti_v2p1](http://www.imsglobal.org/xsd/imsqti_v2p1)"
    xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)"
    xsi:schemaLocation="[http://www.imsglobal.org/xsd/imsqti_v2p1](http://www.imsglobal.org/xsd/imsqti_v2p1) [http://www.imsglobal.org/xsd/qti/qtiv2p1/imsqti_v2p1.xsd](http://www.imsglobal.org/xsd/qti/qtiv2p1/imsqti_v2p1.xsd)"
    identifier="${itemIdentifier}"
    title="${itemTitle}"
    adaptive="false" timeDependent="false">

    <responseDeclaration identifier="RESPONSE" cardinality="single" baseType="identifier">
        <correctResponse>
            <value>${correctChoiceId}</value>
        </correctResponse>
    </responseDeclaration>

    <outcomeDeclaration identifier="SCORE" cardinality="single" baseType="float" normalMaximum="1.0" normalMinimum="0.0">
        <defaultValue>
            <value>0.0</value>
        </defaultValue>
    </outcomeDeclaration>

    <itemBody>
        <p>${questionStem}</p>
        <choiceInteraction responseIdentifier="RESPONSE" shuffle="false" maxChoices="1">
${optionsXml}
        </choiceInteraction>
    </itemBody>

    <responseProcessing template="[http://www.imsglobal.org/question/qti_v2p1/rptemplates/match_correct](http://www.imsglobal.org/question/qti_v2p1/rptemplates/match_correct)"/>

</assessmentItem>`;

                items.push({
                    filename: `item_${itemIndex + 1}.xml`,
                    xmlString: qtiString
                });
            });
            return items;
        }

        function generateManifestXml(qtiItems) {
            let resourcesXml = '';
            qtiItems.forEach(item => {
                if (item && item.filename) {
                     const identifier = item.filename.replace('.xml', '');
                     resourcesXml += `    <resource identifier="${identifier}" type="imsqti_item_xmlv2p1" href="${item.filename}">\n`;
                     resourcesXml += `        <file href="${item.filename}"/>\n`;
                     resourcesXml += `    </resource>\n`;
                }
            });

            const manifestString = `<?xml version="1.0" encoding="UTF-8"?>
<manifest identifier="manifest_${generateUUID()}" xmlns="[http://www.imsglobal.org/xsd/imscp_v1p1](http://www.imsglobal.org/xsd/imscp_v1p1)"
    xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)"
    xsi:schemaLocation="[http://www.imsglobal.org/xsd/imscp_v1p1](http://www.imsglobal.org/xsd/imscp_v1p1) [http://www.imsglobal.org/xsd/imscp_v1p1.xsd](http://www.imsglobal.org/xsd/imscp_v1p1.xsd) [http://www.imsglobal.org/xsd/imsqti_v2p1](http://www.imsglobal.org/xsd/imsqti_v2p1) [http://www.imsglobal.org/xsd/qti/qtiv2p1/imsqti_v2p1.xsd](http://www.imsglobal.org/xsd/qti/qtiv2p1/imsqti_v2p1.xsd)">

    <metadata>
        <schema>IMS Content</schema>
        <schemaversion>1.1.3</schemaversion>
        </metadata>

    <organizations/>

    <resources>
${resourcesXml}
    </resources>

</manifest>`;
            return manifestString;
        }

    </script>

</body>
</html>